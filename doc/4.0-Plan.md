# CS 1440 Assignment 4.0: Software Development Plan

## Phase 0: Requirements Analysis (tag name `4.0-analyzed`)
*(20% of your effort)*

**Important - do not change the code in this phase**

Deliver:

*   [ ] Re-write the instructions in your own words.
    *   If you don't do this, you won't know what you're supposed to do!
    *   Don't leave out details!
*   [ ] Explain the problem this program aims to solve.
    *   Describe what a *good* solution looks like.
    *   List what you already know how to do.
    *   Point out any challenges that you can foresee.
*   [ ] List all of the data that is used by the program, making note of where it comes from.
    *   Explain what form the output will take.
*   [ ] List the algorithms that will be used (but don't write them yet).
*   [ ] **Tag** the last commit in this phase `4.0-analyzed` and push it to GitLab.
    *   *Grace Points: if this tag is pushed before class on the Monday before the due date, you will receive up to 5 points back*

## Refactoring Overview
The objetive of this sprint is to refactor the given mandelbrot program, making it cleaner and more effective, while keeping its functionality.
At this current state, this program's function is to take different fractals as an input, and print them out onto the screen with color.
After briefly looking at the code, it is REALLY bad. There are so many unused variables and imports, confusing names, useless code, and more, and this is only after looking at it very quickly.
This is going to be my main objective: to clean up the code for the future assignment which will include adding new functionalities.

In the process of going through the code, I will include a document including 10 "code smells", simply example of bad code examples. Creating this will also help me become more aware of bad coding habits and help clear the code in the future steps.

Not only am I going to clean the code and its readability, but I will also separate the code into smaller sections, which will be easier to read and more adaptable. 
Currently, the code is broken into three modules: ```main.py```, responsible for calling the other fractals and checking for enough arguments (in theory, it's pretty rough), ```phoenix_fractal.py``` and ```mbrot_fractal```, which are responsible for printing the fractal to the screen.
The difference between the two are, from my understanding, are either two different fractals, or different zoom spots within the mandelbrot fractal (to be explored).
At the end of the sprint, the project should be broken into 6 smaller modules: ```main.py```, ```FractalInformation.py```, ```ImagePainter.py```, ```Palette.py```, ```Mandelbrot.py```, and ```Phoenix.py```. Each will be described in the next section.

Next, in assuring that the user is able to use the function, we will also be adding a user manual to help explain the program's functionality. Creating this user manual should go over everything that the user should expect, what to input, how the program could go wrong, and more. More details will be given in the next section.

Finally, adding onto the functionality this program, I will be adding two extra unit tests for easier refactoring. There is already 6 provided, so the end program should have at least 8 unit tests. There plenty of things that I can test, but I will decide what would be the most beneficial to test once I begin cleaning up the code.

In this assignment, there is a lot that I don't know. The biggest unknowns at this point is first understanding how the fractal is able to print to the screen and how to create new unit tests. I have never had to deal with any of these subject prior to this assignment so it may take some time to wrap my head around it. In addition to testing the code for a better understanding, ChatGPT may be a beneficial tool to use.
I have yet to decide how I will use it, but I hope to use it somehow. I believe that being a computer scientist means keeping up with the time and using every tool at your disposal. Even if I don't need ChatGPT (which I don't) I would still like to use it for this assignment.
## Phase 1: Design (tag name `4.0-designed`)
*(30% of your effort)*

**Important - do not change the code in this phase**

Deliver:

*   [ ] Function signatures that include:
    *   Descriptive names.
    *   Parameter lists.
    *   Documentation strings that explain its purpose and types of inputs and outputs.
*   [ ] Pseudocode that captures how each function works.
    *   Pseudocode != source code.  Do not paste your finished source code into this part of the plan.
*   Explain what happens in the face of good and bad input.
    *   Write a few specific examples that occur to you, and use them later when testing.
*   [ ] **Tag** the last commit in this phase `4.0-designed` and push it to GitLab.
    *   *Grace Points: if this tag is pushed before class on the Monday before the due date, you will receive up to 5 points back*


## User Manual
For the user manual, I used ChatGPT to create a basic outline. I took the idea of all the headings and copied the conclusion section.
Everything else was created by me.

## Unit Test Addition
For this refactor, we are going to need to add a few new unit tests for test driven coding.
I am choosing to add a new test file named ```test_palette``` and put all my new tests in there.
The two things I want to test is that the color palettes have the correct number of colors and only contain strings.
I am new to writing unit tests, so the pseudocode will have very little representation of how the final tests should look like. In other words, this is a conceptual area to start my code.

Pseudocode for the expected number of colors
```
import unittest
from Palette import palette (file will be added later)

class TestPalette(unittest.TestCase):
    def color palette is correct length
        check whether the pallete list has exactly 102 items
```

Pseudocode for checking if all items in color palette list has only strings
```
def colorPaletteOnlyStrings()
    for each color in palette
        the color should be a string
```

Also needs this at the end
```
if __name__ == '__main__':
    unittest.main()
```

## Pseudocode for New Modules
As specified previously, the final project should be split into 6 different modules. The pseudocode below will be pure ideas and nothing more.
If my pseudocode doesn't work, I will mention it in the next phase, and what changes I needed to make. Otherwise, if there isn't any crucial mistakes I made, these plans will stay the same.
Furthermore, I will also work in three phases. I will first go through all three original modules and clean up any code smells that are obvious and improve readability for myself. At this time I will also make sure that all the unit tests and functions are still functioning.
Next, I will go more thoroughly through the modules and fix any functionality issues and anything else wrong with the code. Finally, I will split the code up into the 6 modules and add any new code that is needed.

I also used ChatGPT to understand the code. I only used it when I really didn't understand what it was doing, and all the pseudocode is mine.
### main.py
```
import FractalInformation and ImagePainter

fractalChosen = sys.argv[1]
for each key in FractalInformation
    if the key == fractalChosen
        run ImagePainter passing in the fractal chosen
    else:
        print(Error: fractalChosen is not a fractal
        print please choose one of the following
        for each key in the FractalInformation
            print key

if there are less than 2 arguments
    print provide a fractal
    for each key in the FractalInformation
        print key 
```

### FractalInformation
```
# Will hold a dictionary of all the Mandelbrot and Phoenix configuration
# Should look something like...
fractal = {
        'mandelbrot': {
            'centerX': -0.6,
            'centerY': 0.0,
            'axisLen': 2.5,
            },
            ... More Fractals
            }
          
# This will combine both Mandelbrot and Phoenix together  
```

### ImagePainter
```
Import Palette, Mandelbrot, and Phoenix

def Paint(fractal, window)
    for every row in the in the picture
        create a list for color/index for row
        for every collumn in the picture
            find the current location for the pixel
            check whether the location is a color or index
            add it to the list
    add the list to the img
    print out the pixelsWrittenSoFar

pixelsWrittenSoFar(row)
    percentageOfBarDone = (pixelWidth - rows) / pixelWidth
    format the percent value
    set status bar width
    Add the appropiate number of '='
    return the status percent and status bar
 
mbrot_main(fractal)
    print out the fractal is rendering
    take the current time
    create a tkWindow
    set an image with appropriate width and height
    paint(fractal, window)
    take time again
    print how long it took to finish
    print out that it saved to image to file
    print close the image window to exit the program
    mainloop()
```

### Palette
```
# Holds a list of colors for both phoenix and mbrot
mbrotColor = ['#D8DE97', '#D4DD96', '#D1DD94', '#CDDC93', '#CADC92', '#C6DB91',
...
]

phoenixColor = ['#D8DE97', '#D4DD96', '#D1DD94', '#CDDC93', '#CADC92', '#C6DB91',
...
]
#Only strings should be included!
```

### Phoenix
```
def GetColor(complexNum)
    create the julian constant
    create phoenix constant
    rotate the picture?
    for variable i in range(colorPaletteLen)
        flipped * flipped + julianConstant + (phoenixConstant * previousComplexNum)
        change the new previousComplexNum
        If long equation is greater than 2
            return the gradiant at index i
        else return index of the length of palette - 1
```

### Mandelbrot
```
Very similar thing to Phoenix module
    for variable i in range(colorPaletteLen)
        flipped * flipped + currentComplexNum
        change the new previousComplexNum
        If long equation is greater than 2
            return the gradiant at index i
        else return index of the length of palette - 1

```


## Phase 2: Implementation (tag name `4.0-implemented`)
*(15% of your effort)*

**Finally, you can write code!**

Deliver:

*   [ ] More or less working code.
*   [ ] Note any relevant and interesting events that happened while you wrote the code.
    *   e.g. things you learned, things that didn't go according to plan.
*   [ ] **Tag** the last commit in this phase `4.0-implemented` and push it to GitLab.


## Test Cases Changes
It has come to my attention that I also need to refactor the original 6 unit tests in order to fit my needs.
Since I changed a lot about the code and cleaned/changed the location of the code, I need to change my test a little.
Most of them will remain the same, or partly the same, but some need to be completely changed in order to test worthwhile things.
Below I will tell all the changes I needed to make.

1. Change the location of ```test_pixelsWrittenSoFar``` so it tests within the ```ImagePainter.py``` instead of the ```Mandelbrot.py```. Also added it to the test suite in the ```run_test.py```.
2. Test dealing with the length of the palette was also moved into a new test file named ```test_palette.py```. I also needed to change the test of the Phoenix to be six less than the original.
The reason for this was that the original program added 6 unnecessary black indexes which served no purpose. If I find out late that they did matter, which I doubt they did, I can easily change it back.
3. Had to change the test ```test_dictionaryGetter``` a little more than normal. I had to change where it was looking to the new ```FractalInformation.py``` file and also change the test from asserting in none or isn't none to assertNotIn and assertIn. This method is a lot more intuitive as well and got rid of that awfully long function. Everything else stayed relatively the same.
4. ```getPhoenixIteration``` was a little pain to make. I took all the code from ```getColorFromPalette``` and change it into a test to check the iteration count. This is essentially the same as before, just a little more simplified. Although, converting the original color name into a location iteration number based on the Palette was a little challenging. For each one, I would have to find where the color was located, and count what spot it was in.
I also did this for the ```test_pixelColorOrIndex```, except it no longer gives back a color, just a iteration count. Similar changes were applied
5. I didn't realize that my original test was already essentially done. I decided that the first test I should add would just check if all the palette colors are strings. Not really an in depth test, but I feel it could be helpful. For this, I went through both lists in a loop and asserted that it is a instance of a string.
6. Finally, the last test I added ```test_fractalInformationIsAccurate``` to ```test_fractalInformation```. This test simply checks random pieces of information from the Fractal dictionary and makes sure it's accurate.

## Phase 3: Testing and Debugging (tag name `4.0-tested`)
*(30% of your effort)*

Deliver:

*   [ ] A set of test cases that you have personally run on your computer.
    *   Include a description of what happened for each test case.
    *   For any bugs discovered, describe their cause and remedy.
    *   Write your test cases in plain language such that a non-coder could run them and replicate your experience.
*   [ ] **Tag** the last commit in this phase `4.0-tested` and push it to GitLab.


## Phase 4: Deployment (tag name `4.0-deployed`)
*(5% of your effort)*

Deliver:

*   [ ] **Tag** the last commit in this phase `4.0-deployed` and push it to GitLab.
*   [ ] Your repository is pushed to GitLab.
*   [ ] **Verify** that your final commit was received by browsing to its project page on GitLab.
    *   Ensure the project's URL is correct.
    *   Look for all of the tags in the **Tags** tab.
    *   Review the project to ensure that all required files are present and in correct locations.
    *   Check that unwanted files have not been included.
    *   Make any final touches to documentation, including the Sprint Signature and this Plan.
*   [ ] **Validate** that your submission is complete and correct by cloning it to a new location on your computer and re-running it.
	*	Run your program from the command line so you can see how it will behave when your grader runs it.  **Running it in PyCharm is not good enough!**
    *   Run through your test cases to avoid nasty surprises.
    *   Check that your documentation files are all present.


## Phase 5: Maintenance

Spend a few minutes writing thoughtful answers to these questions.  They are meant to make you think about the long-term consequences of choices you made in this project.

Deliver:

*   [ ] Write brief and honest answers to these questions:
    *   What parts of your program are sloppily written and hard to understand?
        *   Are there parts of your program which you aren't quite sure how/why they work?
        *   If a bug is reported in a few months, how long would it take you to find the cause?
    *   Will your documentation make sense to...
        *   ...anybody besides yourself?
        *   ...yourself in six month's time?
    *   How easy will it be to add a new feature to this program in a year?
    *   Will your program continue to work after upgrading...
        *   ...your computer's hardware?
        *   ...the operating system?
        *   ...to the next version of Python?
*   [ ] Make one final commit and push your **completed** Software Development Plan to GitLab.
*   [ ] Respond to the **Assignment Reflection Survey** on Canvas.
